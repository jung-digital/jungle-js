{"version":3,"sources":["Embers.min.js","/source/Embers.js","/source/src/lib/gx/Spark.js","/source/src/lib/Lib.js","/source/src/lib/core/ComponentBase.js","/source/src/embers/Embers.js"],"names":["_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","undefined","Function","getOwnPropertyDescriptor","get","call","getPrototypeOf","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","global","factory","exports","module","require","define","amd","Embers","util","this","Spark","options","id","pathRedraw","sparkLength","sparkResolution","paths","sparking","a","onFrameCallback","velocity","position","points","pos","push","shift","elapsed","context","updateTail","start","end","Lib","DEFAULT_WIDTH","DEFAULT_HEIGHT","ComponentBase","canvas","ctx","getContext","lastTime","canvasTargetWidth","width","canvasTargetHeight","height","window","addEventListener","resizeHandler","bind","onMouseMoveHandler","onMouseOutHandler","onTouchStartHandler","onTouchMoveHandler","setAttribute","requestAnimationFrame","onFrameFirst","event","Math","min","innerWidth","style","state","resize","console","log","timestamp","onFrame","SPARKS","WIDTH","HEIGHT","SPARK_SOURCE_RADIUS","CHANGE_DIR_TIME_MAX","_ComponentBase","hue","sparkSource","gl","vec2","fromValues","sparks","spark","ratio","strokeStyle","color","r","g","b","lineWidth","size","beginPath","moveTo","lineTo","stroke","_this","clearRect","random","forEach","startSpark","sparkOnFrame","velAngle","PI","sourceAngle","sourceDistance","rgb","hsvToRgb","type","add","cos","sin","scale","heatCurrent","lastAngleChangeTime","life","demo","ran","angle","matrix","mat2","rotate","transformMat2","nextPos","scaleAndAdd","next","y","x","reset","rect","getBoundingClientRect","clientX","left","clientY","top","preventDefault","touches"],"mappings":"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","file":"Embers.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('shared/util/util')) :\n  typeof define === 'function' && define.amd ? define(['shared/util/util'], factory) :\n  global.Embers = factory(global.util)\n}(this, function (util) { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark\n    next(pos) {\n      this.position = pos;\n\n      this.points = this.points || [];\n      this.points.push(pos);\n\n      if (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkLength = options.sparkLength || 200; // Pixel length of the spark\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var Lib_js = new Lib();\n\n  const DEFAULT_WIDTH = 800;\n  const DEFAULT_HEIGHT = 800 / 1.618;\n\n  class ComponentBase {\n    constructor(canvas, id) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n\n      this.lastTime = 0;\n\n      this.canvasTargetWidth = this.width = DEFAULT_WIDTH;\n      this.canvasTargetHeight = this.height = DEFAULT_HEIGHT;\n\n      window.addEventListener('resize', this.resizeHandler.bind(this));\n\n      canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n      canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n      canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n      canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n      canvas.setAttribute('width', DEFAULT_WIDTH);\n      canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n      if (id) {\n        canvas.setAttribute('id', id);\n      }\n\n      window.requestAnimationFrame(this.onFrameFirst.bind(this));\n    }\n\n    resizeHandler(event) {\n      var i = Math.min(800, window.innerWidth);\n\n      canvas.style.width = this.state.canvasTargetWidth = i;\n      canvas.style.height = this.state.canvasTargetHeight = i / 1.618;\n\n      this.resize();\n    }\n\n    resize() {\n      console.log('Resized!', this.state.canvasTargetWidth, this.state.canvasTargetHeight);\n    }\n\n    onMouseMoveHandler() {\n      // noop\n    }\n\n    onMouseOutHandler() {\n      // noop\n    }\n\n    onTouchStartHandler() {\n      // noop\n    }\n\n    onTouchMoveHandler() {\n      // noop\n    }\n\n    onFrameFirst(timestamp) {\n      this.lastTime = timestamp;\n      window.requestAnimationFrame(this.onFrame.bind(this));\n    }\n\n    onFrameHandler(timestamp) {\n      if (!this.lastTime) {\n        this.lastTime = timestamp;\n        this.elapsed = 0.01;\n      } else {\n        this.elapsed = (timestamp - this.lastTime) / 1000;\n      }\n    }\n  }\n\n  /*============================================\n   * Constants\n   *============================================*/\n  const SPARKS = 500;               // Maximum number of sparks to display simulataneously\n  const WIDTH = 800;                // Width of canvas\n  const HEIGHT = 800 / 1.61;        // Height of canvas,\n  const SPARK_SOURCE_RADIUS = 50;   // Spark source radius in pixels\n  const CHANGE_DIR_TIME_MAX = 5000; // The maximum time to wait between changing directions   \n\n  /*============================================\n   * The demo JSX component\n   *============================================*/\n  class Embers extends ComponentBase {\n    constructor(canvas) {\n      super(canvas);\n\n      this.hue = 0;\n\n      this.sparkSource = new gl.vec2.fromValues(WIDTH / 2, HEIGHT / 5);\n\n      this.sparks = [];\n\n      for (var i = 0; i < SPARKS; i++) {\n        this.sparks.push(new Spark({\n          pathRedraw: this.pathRedraw,\n          sparkResolution: 4\n        }));\n      }\n    }\n\n    pathRedraw(spark, start, end, ratio, elapsed, context) {\n      ratio = 1 - ratio;\n\n      context.strokeStyle = 'rgba(' + ~~(spark.options.color.r * 256) + ',' + ~~(spark.options.color.g * 256) + ',' + ~~(spark.options.color.b) * 256 + ',' + ratio + ')';\n      context.lineWidth = spark.options.size * ratio;\n\n      context.beginPath();\n      context.moveTo(start[0], start[1]);\n      context.lineTo(end[0], end[1]);\n      context.stroke();\n    }\n\n    onFrame(timestamp) {\n      this.ctx.clearRect(0, 0, this.state.WIDTH, this.state.HEIGHT);\n      this.elapsed = (timestamp - this.lastTime) / 1000;\n      this.lastTime = timestamp;\n\n      this.hue = Math.random() * Math.random() * 60;\n\n      this.sparks.forEach(spark => {\n        if (!spark.sparking) {\n          this.startSpark(spark);\n        }\n\n        this.sparkOnFrame.call(spark, this);\n\n        spark.onFrame(this.elapsed, this.ctx);\n      });\n\n      window.requestAnimationFrame(this.onFrame.bind(this));\n    }\n\n    startSpark(spark) {\n      var velAngle = Math.random() - .5 - (Math.PI / 2);\n      var sourceAngle = Math.random() * Math.PI * 2;\n      var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n      var rgb = util.hsvToRgb(this.hue, 1, 0.8);\n\n      spark.spark({\n        type: 2,\n        size: (Math.random() * 2) + 1,\n        color: rgb,\n        position: gl.vec2.add(gl.vec2.create(), this.sparkSource, gl.vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n        velocity: gl.vec2.scale(gl.vec2.create(), gl.vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * 150 + 20),\n        heatCurrent: 0,\n        lastAngleChangeTime: 0,\n        life: (Math.random() * 4 + 2)\n      });\n    }\n\n    // 'this' will be the Spark object itself.\n    sparkOnFrame(demo) {\n      var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n      if (ran > CHANGE_DIR_TIME_MAX) {\n        var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n        var matrix = gl.mat2.create();\n        gl.mat2.rotate(matrix, matrix, angle);\n        gl.vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n        this.options.lastAngleChangeTime = demo.lastTime;\n      }\n\n      this.options.heatCurrent += (Math.random());\n      this.options.life -= demo.elapsed;\n\n      var nextPos = gl.vec2.scaleAndAdd(gl.vec2.create(), this.position, this.options.velocity, demo.elapsed);\n      this.next(nextPos);\n\n      if (this.options.life < 0 || nextPos.y > HEIGHT + 50 || nextPos.x < -50 || nextPos.y < -50 || nextPos.x > WIDTH + 50) {\n        this.reset();\n      }\n    }\n\n    onMouseMoveHandler(event) {\n      var rect = this.canvas.getBoundingClientRect();\n      var scale = WIDTH / this.state.canvasTargetWidth;\n\n      this.sparkSource = gl.vec2.fromValues((event.clientX - rect.left) * scale, (event.clientY - rect.top) * scale);\n    }\n\n    onTouchMoveHandler(event) {\n      event.preventDefault();\n\n      var rect = this.canvas.getBoundingClientRect();\n      var scale = WIDTH / this.state.canvasTargetWidth;\n\n      this.sparkSource = gl.vec2.fromValues((event.touches[0].clientX - rect.left) * scale, (event.touches[0].clientY - rect.top) * scale);\n    }\n  }\n\n  return Embers;\n\n}));\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark\n  next(pos) {\n    this.position = pos;\n\n    this.points = this.points || [];\n    this.points.push(pos);\n\n    if (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkLength = options.sparkLength || 200; // Pixel length of the spark\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n","const DEFAULT_WIDTH = 800;\nconst DEFAULT_HEIGHT = 800 / 1.618;\n\nclass ComponentBase {\n  constructor(canvas, id) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n\n    this.lastTime = 0;\n\n    this.canvasTargetWidth = this.width = DEFAULT_WIDTH;\n    this.canvasTargetHeight = this.height = DEFAULT_HEIGHT;\n\n    window.addEventListener('resize', this.resizeHandler.bind(this));\n\n    canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n    canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n    canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n    canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n    canvas.setAttribute('width', DEFAULT_WIDTH);\n    canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n    if (id) {\n      canvas.setAttribute('id', id);\n    }\n\n    window.requestAnimationFrame(this.onFrameFirst.bind(this));\n  }\n\n  resizeHandler(event) {\n    var i = Math.min(800, window.innerWidth);\n\n    canvas.style.width = this.state.canvasTargetWidth = i;\n    canvas.style.height = this.state.canvasTargetHeight = i / 1.618;\n\n    this.resize();\n  }\n\n  resize() {\n    console.log('Resized!', this.state.canvasTargetWidth, this.state.canvasTargetHeight);\n  }\n\n  onMouseMoveHandler() {\n    // noop\n  }\n\n  onMouseOutHandler() {\n    // noop\n  }\n\n  onTouchStartHandler() {\n    // noop\n  }\n\n  onTouchMoveHandler() {\n    // noop\n  }\n\n  onFrameFirst(timestamp) {\n    this.lastTime = timestamp;\n    window.requestAnimationFrame(this.onFrame.bind(this));\n  }\n\n  onFrameHandler(timestamp) {\n    if (!this.lastTime) {\n      this.lastTime = timestamp;\n      this.elapsed = 0.01;\n    } else {\n      this.elapsed = (timestamp - this.lastTime) / 1000;\n    }\n  }\n}\n\nexport default ComponentBase;\n","import Lib from '../lib/Lib.js';\nimport ComponentBase from '../lib/core/ComponentBase.js';\nimport Spark from '../lib/gx/Spark.js';\nimport util from '../shared/util/util';\n\n/*============================================\n * Constants\n *============================================*/\nconst SPARKS = 500;               // Maximum number of sparks to display simulataneously\nconst WIDTH = 800;                // Width of canvas\nconst HEIGHT = 800 / 1.61;        // Height of canvas,\nconst SPARK_SOURCE_RADIUS = 50;   // Spark source radius in pixels\nconst CHANGE_DIR_TIME_MAX = 5000; // The maximum time to wait between changing directions   \n\n/*============================================\n * The demo JSX component\n *============================================*/\nclass Embers extends ComponentBase {\n  constructor(canvas) {\n    super(canvas);\n\n    this.hue = 0;\n\n    this.sparkSource = new gl.vec2.fromValues(WIDTH / 2, HEIGHT / 5);\n\n    this.sparks = [];\n\n    for (var i = 0; i < SPARKS; i++) {\n      this.sparks.push(new Spark({\n        pathRedraw: this.pathRedraw,\n        sparkResolution: 4\n      }));\n    }\n  }\n\n  pathRedraw(spark, start, end, ratio, elapsed, context) {\n    ratio = 1 - ratio;\n\n    context.strokeStyle = 'rgba(' + ~~(spark.options.color.r * 256) + ',' + ~~(spark.options.color.g * 256) + ',' + ~~(spark.options.color.b) * 256 + ',' + ratio + ')';\n    context.lineWidth = spark.options.size * ratio;\n\n    context.beginPath();\n    context.moveTo(start[0], start[1]);\n    context.lineTo(end[0], end[1]);\n    context.stroke();\n  }\n\n  onFrame(timestamp) {\n    this.ctx.clearRect(0, 0, this.state.WIDTH, this.state.HEIGHT);\n    this.elapsed = (timestamp - this.lastTime) / 1000;\n    this.lastTime = timestamp;\n\n    this.hue = Math.random() * Math.random() * 60;\n\n    this.sparks.forEach(spark => {\n      if (!spark.sparking) {\n        this.startSpark(spark);\n      }\n\n      this.sparkOnFrame.call(spark, this);\n\n      spark.onFrame(this.elapsed, this.ctx);\n    });\n\n    window.requestAnimationFrame(this.onFrame.bind(this));\n  }\n\n  startSpark(spark) {\n    var velAngle = Math.random() - .5 - (Math.PI / 2);\n    var sourceAngle = Math.random() * Math.PI * 2;\n    var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n    var rgb = util.hsvToRgb(this.hue, 1, 0.8);\n\n    spark.spark({\n      type: 2,\n      size: (Math.random() * 2) + 1,\n      color: rgb,\n      position: gl.vec2.add(gl.vec2.create(), this.sparkSource, gl.vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n      velocity: gl.vec2.scale(gl.vec2.create(), gl.vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * 150 + 20),\n      heatCurrent: 0,\n      lastAngleChangeTime: 0,\n      life: (Math.random() * 4 + 2)\n    });\n  }\n\n  // 'this' will be the Spark object itself.\n  sparkOnFrame(demo) {\n    var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n    if (ran > CHANGE_DIR_TIME_MAX) {\n      var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n      var matrix = gl.mat2.create();\n      gl.mat2.rotate(matrix, matrix, angle);\n      gl.vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n      this.options.lastAngleChangeTime = demo.lastTime;\n    }\n\n    this.options.heatCurrent += (Math.random());\n    this.options.life -= demo.elapsed;\n\n    var nextPos = gl.vec2.scaleAndAdd(gl.vec2.create(), this.position, this.options.velocity, demo.elapsed);\n    this.next(nextPos);\n\n    if (this.options.life < 0 || nextPos.y > HEIGHT + 50 || nextPos.x < -50 || nextPos.y < -50 || nextPos.x > WIDTH + 50) {\n      this.reset();\n    }\n  }\n\n  onMouseMoveHandler(event) {\n    var rect = this.canvas.getBoundingClientRect();\n    var scale = WIDTH / this.state.canvasTargetWidth;\n\n    this.sparkSource = gl.vec2.fromValues((event.clientX - rect.left) * scale, (event.clientY - rect.top) * scale);\n  }\n\n  onTouchMoveHandler(event) {\n    event.preventDefault();\n\n    var rect = this.canvas.getBoundingClientRect();\n    var scale = WIDTH / this.state.canvasTargetWidth;\n\n    this.sparkSource = gl.vec2.fromValues((event.touches[0].clientX - rect.left) * scale, (event.touches[0].clientY - rect.top) * scale);\n  }\n}\n\nexport default Embers;\n"],"sourceRoot":"/source/"}