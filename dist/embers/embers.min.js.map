{"version":3,"sources":["Embers.min.js","/source/Embers.js","/source/src/lib/util/util.js","/source/src/lib/gx/Spark.js","/source/src/lib/Lib.js","/source/src/lib/core/ComponentBase.js","/source/src/embers/Embers.js"],"names":["_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","undefined","Function","getOwnPropertyDescriptor","get","call","getPrototypeOf","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","global","factory","exports","module","define","amd","Embers","this","_ran","min","max","Math","random","ranItem","arr","floor","isAbove","p1","p2","y","isBelow","isLeft","x","isRight","reverseOf","dir","toward","push","vecFor","side","Sides","LEFT","paper","Point","RIGHT","TOP","BOTTOM","getRandomPointFor","bounds","right","bottom","hsvToRgb","h","s","v","f","p","q","t","r","g","b","Spark","options","id","pathRedraw","sparkResolution","paths","sparking","a","onFrameCallback","velocity","position","points","pos","delta","vec2","sub","deltaNorm","normalize","len","tmp","add","scale","shift","elapsed","context","updateTail","curLen","start","end","Lib","DEFAULT_WIDTH","DEFAULT_HEIGHT","ComponentBase","canvas","ctx","getContext","fillCanvas","lastTime","setTimeout","resizeHandler","bind","canvasTargetWidth","width","canvasTargetHeight","height","window","addEventListener","lastScrollTop","scrollY","_scrollHandler","onMouseMoveHandler","onMouseOutHandler","onTouchStartHandler","onTouchMoveHandler","setAttribute","requestAnimationFrame","_onFrameFirstHandler","event","w","innerWidth","innerHeight","style","resize","deltaY","scrollHandler","console","log","timestamp","_onFrameHandler","onFrameHandler","debug","font","fillStyle","fillText","debugText","round","ran","util","SPARK_COUNT","SPARK_MAX_SIZE","SPARK_MIN_SIZE","SPARK_MAX_VELOCITY","SPARK_MIN_VELOCITY","SPARK_SOURCE_RADIUS","CHANGE_DIR_TIME_MAX","SPARK_RESOLUTION","SPARK_MAX_TAIL_LENGTH","SPARK_MAX_LIFE_S","_ComponentBase","sparkCount","maxSparkSize","minSparkSize","maxSparkVelocity","minSparkVelocity","maxTailLength","maxSparkLife","sparkSource","fromValues","sparks","spark","ratio","rgb","color","l","strokeStyle","lifeRatio","lineWidth","size","beginPath","moveTo","lineTo","stroke","_this","clearRect","forEach","startSpark","sparkOnFrame","onFrame","trans","map","velAngle","PI","sourceAngle","sourceDistance","life","source","boundingRect","getBoundingClientRect","xOffset","yOffset","offset","indexOf","widthProp","parseFloat","heightProp","top","type","cos","sin","heatCurrent","lastAngleChangeTime","glow","flickerSpeed","lifeTotal","demo","angle","matrix","mat2","rotate","transformMat2","nextPos","scaleAndAdd","next","reset"],"mappings":"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","file":"Embers.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Embers = factory()\n}(this, function () { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n    // still looks smooth.\n    next(pos) {\n      if (!pos)\n      {\n        return;\n      }\n\n      this.points = this.points || [];\n\n      var delta = vec2.sub(vec2.create(), pos, this.position);\n      var deltaNorm = vec2.normalize(vec2.create(), delta);\n      var len = vec2.len(delta);\n\n      for (var i = 1; i < len; i += 1.0)\n      {\n        var tmp = vec2.create();\n        var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n        this.points.push(p);\n      }\n\n      this.points.push(pos);\n\n      this.position = pos;\n\n      while (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        var curLen = 0;\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var Lib_js = new Lib();\n\n  const DEFAULT_WIDTH = 800;\n  const DEFAULT_HEIGHT = 800 / 1.618;\n\n  class ComponentBase {\n    constructor(canvas, options, id) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n\n      this.options = options || {};\n      this.options.fillCanvas = this.options.fillCanvas === false ? false : true;\n      this.lastTime = 0;\n\n      if (!this.options.fillCanvas) {\n        this.canvasTargetWidth = this.width = this.options.width || DEFAULT_WIDTH;\n        this.canvasTargetHeight = this.height = this.options.width || DEFAULT_HEIGHT;\n      } else {\n        setTimeout(this.resizeHandler.bind(this), 250);\n      }\n\n      window.addEventListener('resize', this.resizeHandler.bind(this));\n      this.lastScrollTop = window.scrollY;\n\n      window.addEventListener('scroll', this._scrollHandler.bind(this));\n\n      canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n      canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n      canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n      canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n      canvas.setAttribute('width', DEFAULT_WIDTH);\n      canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n      if (id) {\n        canvas.setAttribute('id', id);\n      }\n\n      window.requestAnimationFrame(this._onFrameFirstHandler.bind(this));\n    }\n\n    resizeHandler(event) {\n      if (this.options.fillCanvas) {\n        var w = window.innerWidth;\n        var h = window.innerHeight;\n\n        this.canvas.width = this.canvas.style.width = this.canvasTargetWidth = this.width = w;\n        this.canvas.height = this.canvas.style.height = this.canvasTargetHeight = this.height = h;\n      } else {\n        var i = Math.min(800, window.innerWidth);\n\n        this.canvas.style.width = this.canvasTargetWidth = i;\n        this.canvas.style.height = this.canvasTargetHeight = i / 1.618;\n      }\n\n      this.resize();\n    }\n\n    _scrollHandler(event) {\n      var deltaY = window.scrollY - this.lastScrollTop;\n      this.lastScrollTop = window.scrollY;\n      this.scrollHandler(deltaY);\n    }\n\n    scrollHandler(deltaY) {\n      console.log('Scrolling!', deltaY);\n    }\n\n    resize() {\n      console.log('Resized!', this.canvasTargetWidth, this.canvasTargetHeight);\n    }\n\n    onMouseMoveHandler() {\n      // noop\n    }\n\n    onMouseOutHandler() {\n      // noop\n    }\n\n    onTouchStartHandler() {\n      // noop\n    }\n\n    onTouchMoveHandler() {\n      // noop\n    }\n\n    get debugText() {\n      return this.canvas.width + ', ' + this.canvas.height + ' FPS: ' + Math.round(1 / this.elapsed);\n    }\n\n    _onFrameFirstHandler(timestamp) {\n      this.lastTime = timestamp;\n      window.requestAnimationFrame(this._onFrameHandler.bind(this));\n    }\n\n    _onFrameHandler(timestamp) {\n      window.requestAnimationFrame(this._onFrameHandler.bind(this));\n\n      this.elapsed = Math.min(0.1, (timestamp - this.lastTime) / 1000);\n      this.lastTime = timestamp;\n\n      this.onFrameHandler(this.elapsed);\n\n      if (this.options.debug) {\n        this.ctx.font = '12px Georgia white';\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillText(this.debugText, 10, 50);\n      }\n    }\n  }\n\n  function ran(min, max) {\n    return Math.random() * (max - min) + min;\n  };\n\n  function ranItem(arr) {\n    return arr[Math.floor(ran(0, arr.length - 0.000001))];\n  };\n\n  const Sides = {\n    LEFT: 1,\n    TOP: 2,\n    RIGHT: 3,\n    BOTTOM: 4,\n    ran: function() {\n      return Math.floor(ran(1, 4.99));\n    }\n  };\n\n  function isAbove(p1, p2) {\n    return p1.y < p2.y;\n  }\n  function isBelow(p1, p2) {\n    return p1.y > p2.y;\n  }\n  function isLeft(p1, p2) {\n    return p1.x < p2.x;\n  }\n  function isRight(p1, p2) {\n    return p1.x > p2.x;\n  }\n  function reverseOf(dir) {\n    return (((dir - 1) + 2) % 4) + 1;\n  } // Opposite of LEFT (1) is RIGHT (3) etc.\n  function toward(p1, p2) {\n    var dir = [];\n    if (isAbove(p1, p2)) dir.push(4);\n    if (isBelow(p1, p2)) dir.push(2);\n    if (isLeft(p1, p2)) dir.push(3);\n    if (isRight(p1, p2)) dir.push(1);\n    return dir;\n  }\n\n  function vecFor(side) {\n    if (side == Sides.LEFT) return new paper.Point(-1, 0);\n    if (side == Sides.RIGHT) return new paper.Point(1, 0);\n    if (side == Sides.TOP) return new paper.Point(0, -1);\n    if (side == Sides.BOTTOM) return new paper.Point(0, 1);\n  }\n\n  function getRandomPointFor(side, bounds) {\n    let x = 0;\n    x = side == Sides.RIGHT ? bounds.right : x;\n    x = side == Sides.TOP || side == Sides.BOTTOM ? ran(0, bounds.right) : x;\n\n    let y = 0;\n    y = side == Sides.BOTTOM ? bounds.bottom : y;\n    y = side == Sides.LEFT || side == Sides.RIGHT ? ran(0, bounds.bottom) : y;\n\n    return new paper.Point(x, y);\n  }\n\n  function hsvToRgb(h, s, v) {\n    var i;\n    var f;\n    var p;\n    var q;\n    var t;\n    var r;\n    var g;\n    var b;\n    if (s == 0) {\n      // achromatic (grey)\n      r = g = b = v;\n    } else {\n      h /= 60; // sector 0 to 5\n      i = Math.floor(h);\n      f = h - i; // factorial part of h\n      p = v * (1 - s);\n      q = v * (1 - s * f);\n      t = v * (1 - s * (1 - f));\n      switch (i) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        default:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n\n  var util = {\n    ran: ran,\n    ranItem: ranItem,\n    Sides: Sides,\n    isAbove: isAbove,\n    isBelow: isBelow,\n    isLeft: isLeft,\n    isRight: isRight,\n    reverseOf: reverseOf,\n    toward: toward,\n    vecFor: vecFor,\n    hsvToRgb: hsvToRgb,\n    getRandomPointFor: getRandomPointFor\n  };\n\n  /*============================================\n   * Constants\n   *============================================*/\n  const SPARK_COUNT = 100;              // Maximum number of sparks to display simultaneously\n  const SPARK_MAX_SIZE = 3.4;\n  const SPARK_MIN_SIZE = 1;\n  const SPARK_MAX_VELOCITY = 70;\n  const SPARK_MIN_VELOCITY = 20;\n  const SPARK_SOURCE_RADIUS = 40;       // Spark source radius in pixels\n  const CHANGE_DIR_TIME_MAX = 5000;     // The maximum time to wait between changing directions\n  const SPARK_RESOLUTION = 10;          // The number of tail segments of the spark.\n  const SPARK_MAX_TAIL_LENGTH = 20;\n  const SPARK_MAX_LIFE_S = 10;\n\n  /*============================================\n   * The demo JSX component\n   *============================================*/\n  class Embers extends ComponentBase {\n    constructor(canvas, options) {\n      super(canvas, options);\n\n      this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n      this.options.maxSparkSize = this.options.maxSparkSize || SPARK_MAX_SIZE;\n      this.options.minSparkSize = this.options.minSparkSize || SPARK_MIN_SIZE;\n      this.options.maxSparkVelocity = this.options.maxSparkVelocity || SPARK_MAX_VELOCITY;\n      this.options.minSparkVelocity = this.options.minSparkVelocity || SPARK_MIN_VELOCITY;\n      this.options.maxTailLength = this.options.maxTailLength || SPARK_MAX_TAIL_LENGTH;\n      this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n      this.options.maxSparkLife = this.options.maxSparkLife || SPARK_MAX_LIFE_S;\n\n      this.sparkSource = this.options.sparkSource ? this.options.sparkSource : new vec2.fromValues(this.width / 2, this.height / 5);\n\n      this.sparks = [];\n\n      for (var i = 0; i < this.options.sparkCount; i++) {\n        this.sparks.push(new Spark({\n          pathRedraw: this.pathRedraw.bind(this),\n          sparkResolution: 4\n        }));\n      }\n    }\n\n    pathRedraw(spark, start, end, curLen, ratio, elapsed, context) {\n      ratio =  1 - (curLen / this.options.maxTailLength);\n\n      var rgb = util.hsvToRgb(spark.options.color.h, spark.options.color.s, spark.options.color.l);\n\n      context.strokeStyle = 'rgba(' + ~~(rgb.r * 256) + ',' + ~~(rgb.g * 256) + ',' + ~~(rgb.b) * 256 + ',' + (ratio * spark.options.lifeRatio) + ')';\n      context.lineWidth = spark.options.size * ratio;\n\n      context.beginPath();\n      context.moveTo(start[0], start[1]);\n      context.lineTo(end[0], end[1]);\n      context.stroke();\n    }\n\n    onFrameHandler(elapsed) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      this.sparks.forEach(spark => {\n        if (!spark.sparking) {\n          if (Math.random() > 1 - (elapsed * 1/5))\n          {\n            this.startSpark(spark);\n          }\n          else return;\n        }\n\n        this.sparkOnFrame.call(spark, this);\n\n        spark.onFrame(this.elapsed, this.ctx);\n      });\n    }\n\n    scrollHandler(deltaY) {\n      var trans = vec2.fromValues(0, -deltaY);\n      this.sparks.forEach(spark => {\n        if (spark.sparking) {\n          spark.points = spark.points.map(p => vec2.add(vec2.create(), p, trans));\n\n          vec2.add(spark.position, spark.position, trans);\n        }\n      });\n    }\n\n    startSpark(spark) {\n      var velAngle = Math.random() - .5 - (Math.PI / 2);\n      var sourceAngle = Math.random() * Math.PI * 2;\n      var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n      var life = (Math.random() * this.options.maxSparkLife/2) + this.options.maxSparkLife / 2;\n      var source = this.sparkSource;\n\n      if (source.target) {\n        var boundingRect = source.target.getBoundingClientRect(); // Get rect ya'll\n        var xOffset = 0;\n        var yOffset = 0;\n\n        if (source.offset && source.offset.x) {\n          xOffset = source.offset.x.indexOf('%') != -1 ? source.target[source.widthProp] * (parseFloat(source.offset.x) / 100) : source.offset.x;\n        }\n        if (source.offset && source.offset.y) {\n          yOffset = source.offset.y.indexOf('%') != -1 ? source.target[source.heightProp] * (parseFloat(source.offset.y) / 100) : source.offset.y;\n        }\n\n        source = vec2.fromValues(xOffset, Math.min(yOffset + boundingRect.top, window.innerHeight));\n      } else {\n        throw 'Huge error';\n      }\n\n      spark.spark({\n        type: 2,\n        sparkResolution: SPARK_RESOLUTION,\n        size: (Math.random() * (this.options.maxSparkSize - this.options.minSparkSize)) + this.options.minSparkSize,\n        color: {\n          h: Math.random() * 28 + 20,\n          s: Math.random() * 0.4 + 0.6,\n          l: 1\n        },\n        position: vec2.add(vec2.create(), source, vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n        velocity: vec2.scale(vec2.create(), vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * (this.options.maxSparkVelocity - this.options.minSparkVelocity) + this.options.minSparkVelocity),\n        heatCurrent: 0,\n        lastAngleChangeTime: 0,\n        glow: (Math.random() * 0.8) + 0.2,\n        flickerSpeed: Math.random(),\n        life: life,\n        lifeTotal: this.options.maxSparkLife\n      });\n    }\n\n    // 'this' will be the Spark object itself.\n    sparkOnFrame(demo) {\n      var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n      if (ran > CHANGE_DIR_TIME_MAX) {\n        var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n        var matrix = mat2.create();\n        mat2.rotate(matrix, matrix, angle);\n        vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n        this.options.lastAngleChangeTime = demo.lastTime;\n      }\n\n      this.options.heatCurrent += (Math.random());\n      this.options.life -= demo.elapsed;\n      this.options.color.l = (this.options.life / this.options.lifeTotal) * this.options.glow;\n      this.options.lifeRatio = this.options.life / this.options.lifeTotal;\n\n      var nextPos = vec2.scaleAndAdd(vec2.create(), this.position, this.options.velocity, demo.elapsed);\n      this.next(nextPos);\n\n      if (this.options.life < 0 ||\n          nextPos[1] > demo.canvas.height ||\n          nextPos[0] < 0 ||\n          nextPos[1] < 0 ||\n          nextPos[0] > demo.canvas.width) {\n        console.log('Death of spark')\n        this.reset();\n      }\n    }\n  }\n\n  return Embers;\n\n}));\n","export function ran(min, max) {\n  return Math.random() * (max - min) + min;\n};\n\nexport function ranItem(arr) {\n  return arr[Math.floor(ran(0, arr.length - 0.000001))];\n};\n\nexport const Sides = {\n  LEFT: 1,\n  TOP: 2,\n  RIGHT: 3,\n  BOTTOM: 4,\n  ran: function() {\n    return Math.floor(ran(1, 4.99));\n  }\n};\n\nexport function isAbove(p1, p2) {\n  return p1.y < p2.y;\n}\nexport function isBelow(p1, p2) {\n  return p1.y > p2.y;\n}\nexport function isLeft(p1, p2) {\n  return p1.x < p2.x;\n}\nexport function isRight(p1, p2) {\n  return p1.x > p2.x;\n}\nexport function reverseOf(dir) {\n  return (((dir - 1) + 2) % 4) + 1;\n} // Opposite of LEFT (1) is RIGHT (3) etc.\nexport function toward(p1, p2) {\n  var dir = [];\n  if (isAbove(p1, p2)) dir.push(4);\n  if (isBelow(p1, p2)) dir.push(2);\n  if (isLeft(p1, p2)) dir.push(3);\n  if (isRight(p1, p2)) dir.push(1);\n  return dir;\n}\n\nexport function vecFor(side) {\n  if (side == Sides.LEFT) return new paper.Point(-1, 0);\n  if (side == Sides.RIGHT) return new paper.Point(1, 0);\n  if (side == Sides.TOP) return new paper.Point(0, -1);\n  if (side == Sides.BOTTOM) return new paper.Point(0, 1);\n}\n\nexport function getRandomPointFor(side, bounds) {\n  let x = 0;\n  x = side == Sides.RIGHT ? bounds.right : x;\n  x = side == Sides.TOP || side == Sides.BOTTOM ? ran(0, bounds.right) : x;\n\n  let y = 0;\n  y = side == Sides.BOTTOM ? bounds.bottom : y;\n  y = side == Sides.LEFT || side == Sides.RIGHT ? ran(0, bounds.bottom) : y;\n\n  return new paper.Point(x, y);\n}\n\nexport function hsvToRgb(h, s, v) {\n  var i;\n  var f;\n  var p;\n  var q;\n  var t;\n  var r;\n  var g;\n  var b;\n  if (s == 0) {\n    // achromatic (grey)\n    r = g = b = v;\n  } else {\n    h /= 60; // sector 0 to 5\n    i = Math.floor(h);\n    f = h - i; // factorial part of h\n    p = v * (1 - s);\n    q = v * (1 - s * f);\n    t = v * (1 - s * (1 - f));\n    switch (i) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n      default:\n        r = v;\n        g = p;\n        b = q;\n        break;\n    }\n  }\n\n  return {\n    r: r,\n    g: g,\n    b: b\n  };\n}\n\nexport default {\n  ran: ran,\n  ranItem: ranItem,\n  Sides: Sides,\n  isAbove: isAbove,\n  isBelow: isBelow,\n  isLeft: isLeft,\n  isRight: isRight,\n  reverseOf: reverseOf,\n  toward: toward,\n  vecFor: vecFor,\n  hsvToRgb: hsvToRgb,\n  getRandomPointFor: getRandomPointFor\n};\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n  // still looks smooth.\n  next(pos) {\n    if (!pos)\n    {\n      return;\n    }\n\n    this.points = this.points || [];\n\n    var delta = vec2.sub(vec2.create(), pos, this.position);\n    var deltaNorm = vec2.normalize(vec2.create(), delta);\n    var len = vec2.len(delta);\n\n    for (var i = 1; i < len; i += 1.0)\n    {\n      var tmp = vec2.create();\n      var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n      this.points.push(p);\n    }\n\n    this.points.push(pos);\n\n    this.position = pos;\n\n    while (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      var curLen = 0;\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n","const DEFAULT_WIDTH = 800;\nconst DEFAULT_HEIGHT = 800 / 1.618;\n\nclass ComponentBase {\n  constructor(canvas, options, id) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n\n    this.options = options || {};\n    this.options.fillCanvas = this.options.fillCanvas === false ? false : true;\n    this.lastTime = 0;\n\n    if (!this.options.fillCanvas) {\n      this.canvasTargetWidth = this.width = this.options.width || DEFAULT_WIDTH;\n      this.canvasTargetHeight = this.height = this.options.width || DEFAULT_HEIGHT;\n    } else {\n      setTimeout(this.resizeHandler.bind(this), 250);\n    }\n\n    window.addEventListener('resize', this.resizeHandler.bind(this));\n    this.lastScrollTop = window.scrollY;\n\n    window.addEventListener('scroll', this._scrollHandler.bind(this));\n\n    canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n    canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n    canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n    canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n    canvas.setAttribute('width', DEFAULT_WIDTH);\n    canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n    if (id) {\n      canvas.setAttribute('id', id);\n    }\n\n    window.requestAnimationFrame(this._onFrameFirstHandler.bind(this));\n  }\n\n  resizeHandler(event) {\n    if (this.options.fillCanvas) {\n      var w = window.innerWidth;\n      var h = window.innerHeight;\n\n      this.canvas.width = this.canvas.style.width = this.canvasTargetWidth = this.width = w;\n      this.canvas.height = this.canvas.style.height = this.canvasTargetHeight = this.height = h;\n    } else {\n      var i = Math.min(800, window.innerWidth);\n\n      this.canvas.style.width = this.canvasTargetWidth = i;\n      this.canvas.style.height = this.canvasTargetHeight = i / 1.618;\n    }\n\n    this.resize();\n  }\n\n  _scrollHandler(event) {\n    var deltaY = window.scrollY - this.lastScrollTop;\n    this.lastScrollTop = window.scrollY;\n    this.scrollHandler(deltaY);\n  }\n\n  scrollHandler(deltaY) {\n    console.log('Scrolling!', deltaY);\n  }\n\n  resize() {\n    console.log('Resized!', this.canvasTargetWidth, this.canvasTargetHeight);\n  }\n\n  onMouseMoveHandler() {\n    // noop\n  }\n\n  onMouseOutHandler() {\n    // noop\n  }\n\n  onTouchStartHandler() {\n    // noop\n  }\n\n  onTouchMoveHandler() {\n    // noop\n  }\n\n  get debugText() {\n    return this.canvas.width + ', ' + this.canvas.height + ' FPS: ' + Math.round(1 / this.elapsed);\n  }\n\n  _onFrameFirstHandler(timestamp) {\n    this.lastTime = timestamp;\n    window.requestAnimationFrame(this._onFrameHandler.bind(this));\n  }\n\n  _onFrameHandler(timestamp) {\n    window.requestAnimationFrame(this._onFrameHandler.bind(this));\n\n    this.elapsed = Math.min(0.1, (timestamp - this.lastTime) / 1000);\n    this.lastTime = timestamp;\n\n    this.onFrameHandler(this.elapsed);\n\n    if (this.options.debug) {\n      this.ctx.font = '12px Georgia white';\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText(this.debugText, 10, 50);\n    }\n  }\n}\n\nexport default ComponentBase;\n","import Lib from '../lib/Lib.js';\nimport ComponentBase from '../lib/core/ComponentBase.js';\nimport Spark from '../lib/gx/Spark.js';\nimport util from '../lib/util/util.js';\n\n/*============================================\n * Constants\n *============================================*/\nconst SPARK_COUNT = 100;              // Maximum number of sparks to display simultaneously\nconst SPARK_MAX_SIZE = 3.4;\nconst SPARK_MIN_SIZE = 1;\nconst SPARK_MAX_VELOCITY = 70;\nconst SPARK_MIN_VELOCITY = 20;\nconst SPARK_SOURCE_RADIUS = 40;       // Spark source radius in pixels\nconst CHANGE_DIR_TIME_MAX = 5000;     // The maximum time to wait between changing directions\nconst SPARK_RESOLUTION = 10;          // The number of tail segments of the spark.\nconst SPARK_MAX_TAIL_LENGTH = 20;\nconst SPARK_MAX_LIFE_S = 10;\n\n/*============================================\n * The demo JSX component\n *============================================*/\nclass Embers extends ComponentBase {\n  constructor(canvas, options) {\n    super(canvas, options);\n\n    this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n    this.options.maxSparkSize = this.options.maxSparkSize || SPARK_MAX_SIZE;\n    this.options.minSparkSize = this.options.minSparkSize || SPARK_MIN_SIZE;\n    this.options.maxSparkVelocity = this.options.maxSparkVelocity || SPARK_MAX_VELOCITY;\n    this.options.minSparkVelocity = this.options.minSparkVelocity || SPARK_MIN_VELOCITY;\n    this.options.maxTailLength = this.options.maxTailLength || SPARK_MAX_TAIL_LENGTH;\n    this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n    this.options.maxSparkLife = this.options.maxSparkLife || SPARK_MAX_LIFE_S;\n\n    this.sparkSource = this.options.sparkSource ? this.options.sparkSource : new vec2.fromValues(this.width / 2, this.height / 5);\n\n    this.sparks = [];\n\n    for (var i = 0; i < this.options.sparkCount; i++) {\n      this.sparks.push(new Spark({\n        pathRedraw: this.pathRedraw.bind(this),\n        sparkResolution: 4\n      }));\n    }\n  }\n\n  pathRedraw(spark, start, end, curLen, ratio, elapsed, context) {\n    ratio =  1 - (curLen / this.options.maxTailLength);\n\n    var rgb = util.hsvToRgb(spark.options.color.h, spark.options.color.s, spark.options.color.l);\n\n    context.strokeStyle = 'rgba(' + ~~(rgb.r * 256) + ',' + ~~(rgb.g * 256) + ',' + ~~(rgb.b) * 256 + ',' + (ratio * spark.options.lifeRatio) + ')';\n    context.lineWidth = spark.options.size * ratio;\n\n    context.beginPath();\n    context.moveTo(start[0], start[1]);\n    context.lineTo(end[0], end[1]);\n    context.stroke();\n  }\n\n  onFrameHandler(elapsed) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.sparks.forEach(spark => {\n      if (!spark.sparking) {\n        if (Math.random() > 1 - (elapsed * 1/5))\n        {\n          this.startSpark(spark);\n        }\n        else return;\n      }\n\n      this.sparkOnFrame.call(spark, this);\n\n      spark.onFrame(this.elapsed, this.ctx);\n    });\n  }\n\n  scrollHandler(deltaY) {\n    var trans = vec2.fromValues(0, -deltaY);\n    this.sparks.forEach(spark => {\n      if (spark.sparking) {\n        spark.points = spark.points.map(p => vec2.add(vec2.create(), p, trans));\n\n        vec2.add(spark.position, spark.position, trans);\n      }\n    });\n  }\n\n  startSpark(spark) {\n    var velAngle = Math.random() - .5 - (Math.PI / 2);\n    var sourceAngle = Math.random() * Math.PI * 2;\n    var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n    var life = (Math.random() * this.options.maxSparkLife/2) + this.options.maxSparkLife / 2;\n    var source = this.sparkSource;\n\n    if (source.target) {\n      var boundingRect = source.target.getBoundingClientRect(); // Get rect ya'll\n      var xOffset = 0;\n      var yOffset = 0;\n\n      if (source.offset && source.offset.x) {\n        xOffset = source.offset.x.indexOf('%') != -1 ? source.target[source.widthProp] * (parseFloat(source.offset.x) / 100) : source.offset.x;\n      }\n      if (source.offset && source.offset.y) {\n        yOffset = source.offset.y.indexOf('%') != -1 ? source.target[source.heightProp] * (parseFloat(source.offset.y) / 100) : source.offset.y;\n      }\n\n      source = vec2.fromValues(xOffset, Math.min(yOffset + boundingRect.top, window.innerHeight));\n    } else {\n      throw 'Huge error';\n    }\n\n    spark.spark({\n      type: 2,\n      sparkResolution: SPARK_RESOLUTION,\n      size: (Math.random() * (this.options.maxSparkSize - this.options.minSparkSize)) + this.options.minSparkSize,\n      color: {\n        h: Math.random() * 28 + 20,\n        s: Math.random() * 0.4 + 0.6,\n        l: 1\n      },\n      position: vec2.add(vec2.create(), source, vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n      velocity: vec2.scale(vec2.create(), vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * (this.options.maxSparkVelocity - this.options.minSparkVelocity) + this.options.minSparkVelocity),\n      heatCurrent: 0,\n      lastAngleChangeTime: 0,\n      glow: (Math.random() * 0.8) + 0.2,\n      flickerSpeed: Math.random(),\n      life: life,\n      lifeTotal: this.options.maxSparkLife\n    });\n  }\n\n  // 'this' will be the Spark object itself.\n  sparkOnFrame(demo) {\n    var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n    if (ran > CHANGE_DIR_TIME_MAX) {\n      var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n      var matrix = mat2.create();\n      mat2.rotate(matrix, matrix, angle);\n      vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n      this.options.lastAngleChangeTime = demo.lastTime;\n    }\n\n    this.options.heatCurrent += (Math.random());\n    this.options.life -= demo.elapsed;\n    this.options.color.l = (this.options.life / this.options.lifeTotal) * this.options.glow;\n    this.options.lifeRatio = this.options.life / this.options.lifeTotal;\n\n    var nextPos = vec2.scaleAndAdd(vec2.create(), this.position, this.options.velocity, demo.elapsed);\n    this.next(nextPos);\n\n    if (this.options.life < 0 ||\n        nextPos[1] > demo.canvas.height ||\n        nextPos[0] < 0 ||\n        nextPos[1] < 0 ||\n        nextPos[0] > demo.canvas.width) {\n      console.log('Death of spark')\n      this.reset();\n    }\n  }\n}\n\nexport default Embers;\n"],"sourceRoot":"/source/"}