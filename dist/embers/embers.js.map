{"version":3,"sources":["Embers.js","src/lib/gx/Spark.js","src/lib/Lib.js","src/lib/core/ComponentBase.js","src/lib/util/util.js","src/embers/Embers.js"],"names":[],"mappings":"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","file":"Embers.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Embers = factory()\n}(this, function () { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n    // still looks smooth.\n    next(pos) {\n      if (!pos)\n      {\n        return;\n      }\n\n      this.points = this.points || [];\n\n      var delta = vec2.sub(vec2.create(), pos, this.position);\n      var deltaNorm = vec2.normalize(vec2.create(), delta);\n      var len = vec2.len(delta);\n\n      for (var i = 1; i < len; i += 1.0)\n      {\n        var tmp = vec2.create();\n        var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n        this.points.push(p);\n      }\n\n      this.points.push(pos);\n\n      this.position = pos;\n\n      while (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        var curLen = 0;\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var Lib_js = new Lib();\n\n  const DEFAULT_WIDTH = 800;\n  const DEFAULT_HEIGHT = 800 / 1.618;\n\n  class ComponentBase {\n    constructor(canvas, options, id) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n\n      this.options = options || {};\n      this.options.fillCanvas = this.options.fillCanvas === false ? false : true;\n      this.lastTime = 0;\n\n      if (!this.options.fillCanvas) {\n        this.canvasTargetWidth = this.width = this.options.width || DEFAULT_WIDTH;\n        this.canvasTargetHeight = this.height = this.options.width || DEFAULT_HEIGHT;\n      } else {\n        setTimeout(this.resizeHandler.bind(this), 250);\n      }\n\n      window.addEventListener('resize', this.resizeHandler.bind(this));\n      this.lastScrollTop = window.scrollY;\n\n      window.addEventListener('scroll', this._scrollHandler.bind(this));\n\n      canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n      canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n      canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n      canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n      canvas.setAttribute('width', DEFAULT_WIDTH);\n      canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n      if (id) {\n        canvas.setAttribute('id', id);\n      }\n\n      window.requestAnimationFrame(this._onFrameFirstHandler.bind(this));\n    }\n\n    resizeHandler(event) {\n      if (this.options.fillCanvas) {\n        var w = window.innerWidth;\n        var h = window.innerHeight;\n\n        this.canvas.width = this.canvas.style.width = this.canvasTargetWidth = this.width = w;\n        this.canvas.height = this.canvas.style.height = this.canvasTargetHeight = this.height = h;\n      } else {\n        var i = Math.min(800, window.innerWidth);\n\n        this.canvas.style.width = this.canvasTargetWidth = i;\n        this.canvas.style.height = this.canvasTargetHeight = i / 1.618;\n      }\n\n      this.resize();\n    }\n\n    _scrollHandler(event) {\n      var deltaY = window.scrollY - this.lastScrollTop;\n      this.lastScrollTop = window.scrollY;\n      this.scrollHandler(deltaY);\n    }\n\n    scrollHandler(deltaY) {\n      console.log('Scrolling!', deltaY);\n    }\n\n    resize() {\n      console.log('Resized!', this.canvasTargetWidth, this.canvasTargetHeight);\n    }\n\n    onMouseMoveHandler() {\n      // noop\n    }\n\n    onMouseOutHandler() {\n      // noop\n    }\n\n    onTouchStartHandler() {\n      // noop\n    }\n\n    onTouchMoveHandler() {\n      // noop\n    }\n\n    get debugText() {\n      return this.canvas.width + ', ' + this.canvas.height + ' FPS: ' + Math.round(1 / this.elapsed);\n    }\n\n    _onFrameFirstHandler(timestamp) {\n      this.lastTime = timestamp;\n      window.requestAnimationFrame(this._onFrameHandler.bind(this));\n    }\n\n    _onFrameHandler(timestamp) {\n      window.requestAnimationFrame(this._onFrameHandler.bind(this));\n\n      this.elapsed = (timestamp - this.lastTime) / 1000;\n      this.lastTime = timestamp;\n\n      this.onFrameHandler(this.elapsed);\n\n      if (this.options.debug) {\n        this.ctx.font = '12px Georgia white';\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillText(this.debugText, 10, 50);\n      }\n    }\n  }\n\n  function ran(min, max) {\n    return Math.random() * (max - min) + min;\n  };\n\n  function ranItem(arr) {\n    return arr[Math.floor(ran(0, arr.length - 0.000001))];\n  };\n\n  const Sides = {\n    LEFT: 1,\n    TOP: 2,\n    RIGHT: 3,\n    BOTTOM: 4,\n    ran: function() {\n      return Math.floor(ran(1, 4.99));\n    }\n  };\n\n  function isAbove(p1, p2) {\n    return p1.y < p2.y;\n  }\n  function isBelow(p1, p2) {\n    return p1.y > p2.y;\n  }\n  function isLeft(p1, p2) {\n    return p1.x < p2.x;\n  }\n  function isRight(p1, p2) {\n    return p1.x > p2.x;\n  }\n  function reverseOf(dir) {\n    return (((dir - 1) + 2) % 4) + 1;\n  } // Opposite of LEFT (1) is RIGHT (3) etc.\n  function toward(p1, p2) {\n    var dir = [];\n    if (isAbove(p1, p2)) dir.push(4);\n    if (isBelow(p1, p2)) dir.push(2);\n    if (isLeft(p1, p2)) dir.push(3);\n    if (isRight(p1, p2)) dir.push(1);\n    return dir;\n  }\n\n  function vecFor(side) {\n    if (side == Sides.LEFT) return new paper.Point(-1, 0);\n    if (side == Sides.RIGHT) return new paper.Point(1, 0);\n    if (side == Sides.TOP) return new paper.Point(0, -1);\n    if (side == Sides.BOTTOM) return new paper.Point(0, 1);\n  }\n\n  function getRandomPointFor(side, bounds) {\n    let x = 0;\n    x = side == Sides.RIGHT ? bounds.right : x;\n    x = side == Sides.TOP || side == Sides.BOTTOM ? ran(0, bounds.right) : x;\n\n    let y = 0;\n    y = side == Sides.BOTTOM ? bounds.bottom : y;\n    y = side == Sides.LEFT || side == Sides.RIGHT ? ran(0, bounds.bottom) : y;\n\n    return new paper.Point(x, y);\n  }\n\n  function hsvToRgb(h, s, v) {\n    var i;\n    var f;\n    var p;\n    var q;\n    var t;\n    var r;\n    var g;\n    var b;\n    if (s == 0) {\n      // achromatic (grey)\n      r = g = b = v;\n    } else {\n      h /= 60; // sector 0 to 5\n      i = Math.floor(h);\n      f = h - i; // factorial part of h\n      p = v * (1 - s);\n      q = v * (1 - s * f);\n      t = v * (1 - s * (1 - f));\n      switch (i) {\n        case 0:\n          r = v;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = v;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = v;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = v;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = v;\n          break;\n        default:\n          r = v;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n\n  var util = {\n    ran: ran,\n    ranItem: ranItem,\n    Sides: Sides,\n    isAbove: isAbove,\n    isBelow: isBelow,\n    isLeft: isLeft,\n    isRight: isRight,\n    reverseOf: reverseOf,\n    toward: toward,\n    vecFor: vecFor,\n    hsvToRgb: hsvToRgb,\n    getRandomPointFor: getRandomPointFor\n  };\n\n  /*============================================\n   * Constants\n   *============================================*/\n  const SPARK_COUNT = 100;              // Maximum number of sparks to display simultaneously\n  const SPARK_MAX_SIZE = 3.4;\n  const SPARK_MIN_SIZE = 1;\n  const SPARK_MAX_VELOCITY = 70;\n  const SPARK_MIN_VELOCITY = 20;\n  const SPARK_SOURCE_RADIUS = 40;       // Spark source radius in pixels\n  const CHANGE_DIR_TIME_MAX = 5000;     // The maximum time to wait between changing directions\n  const SPARK_RESOLUTION = 10;          // The number of tail segments of the spark.\n  const SPARK_MAX_TAIL_LENGTH = 20;\n  const SPARK_MAX_LIFE_S = 10;\n\n  /*============================================\n   * The demo JSX component\n   *============================================*/\n  class Embers extends ComponentBase {\n    constructor(canvas, options) {\n      super(canvas, options);\n\n      this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n      this.options.maxSparkSize = this.options.maxSparkSize || SPARK_MAX_SIZE;\n      this.options.minSparkSize = this.options.minSparkSize || SPARK_MIN_SIZE;\n      this.options.maxSparkVelocity = this.options.maxSparkVelocity || SPARK_MAX_VELOCITY;\n      this.options.minSparkVelocity = this.options.minSparkVelocity || SPARK_MIN_VELOCITY;\n      this.options.maxTailLength = this.options.maxTailLength || SPARK_MAX_TAIL_LENGTH;\n      this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n      this.options.maxSparkLife = this.options.maxSparkLife || SPARK_MAX_LIFE_S;\n\n      this.sparkSource = this.options.sparkSource ? this.options.sparkSource : new vec2.fromValues(this.width / 2, this.height / 5);\n\n      this.sparks = [];\n\n      for (var i = 0; i < this.options.sparkCount; i++) {\n        this.sparks.push(new Spark({\n          pathRedraw: this.pathRedraw.bind(this),\n          sparkResolution: 4\n        }));\n      }\n    }\n\n    pathRedraw(spark, start, end, curLen, ratio, elapsed, context) {\n      ratio =  1 - (curLen / this.options.maxTailLength);\n\n      var rgb = util.hsvToRgb(spark.options.color.h, spark.options.color.s, spark.options.color.l);\n\n      context.strokeStyle = 'rgba(' + ~~(rgb.r * 256) + ',' + ~~(rgb.g * 256) + ',' + ~~(rgb.b) * 256 + ',' + (ratio * spark.options.lifeRatio) + ')';\n      context.lineWidth = spark.options.size * ratio;\n\n      context.beginPath();\n      context.moveTo(start[0], start[1]);\n      context.lineTo(end[0], end[1]);\n      context.stroke();\n    }\n\n    onFrameHandler(elapsed) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n      this.sparks.forEach(spark => {\n        if (!spark.sparking) {\n          if (Math.random() > 0.95)\n          {\n            this.startSpark(spark);\n          }\n          else return;\n        }\n\n        this.sparkOnFrame.call(spark, this);\n\n        spark.onFrame(this.elapsed, this.ctx);\n      });\n    }\n\n    scrollHandler(deltaY) {\n      var trans = vec2.fromValues(0, -deltaY);\n      this.sparks.forEach(spark => {\n        if (spark.sparking) {\n          spark.points = spark.points.map(p => vec2.add(vec2.create(), p, trans));\n\n          vec2.add(spark.position, spark.position, trans);\n        }\n      });\n    }\n\n    startSpark(spark) {\n      var velAngle = Math.random() - .5 - (Math.PI / 2);\n      var sourceAngle = Math.random() * Math.PI * 2;\n      var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n      var life = (Math.random() * this.options.maxSparkLife/2) + this.options.maxSparkLife / 2;\n      var source = this.sparkSource;\n\n      if (source.target) {\n        var boundingRect = source.target.getBoundingClientRect(); // Get rect ya'll\n        var xOffset = 0;\n        var yOffset = 0;\n\n        if (source.offset && source.offset.x) {\n          xOffset = source.offset.x.indexOf('%') != -1 ? source.target[source.widthProp] * (parseFloat(source.offset.x) / 100) : source.offset.x;\n        }\n        if (source.offset && source.offset.y) {\n          yOffset = source.offset.y.indexOf('%') != -1 ? source.target[source.heightProp] * (parseFloat(source.offset.y) / 100) : source.offset.y;\n        }\n\n        source = vec2.fromValues(xOffset, Math.min(yOffset + boundingRect.top, window.innerHeight));\n      } else {\n        throw 'Huge error';\n      }\n\n      spark.spark({\n        type: 2,\n        sparkResolution: SPARK_RESOLUTION,\n        size: (Math.random() * (this.options.maxSparkSize - this.options.minSparkSize)) + this.options.minSparkSize,\n        color: {\n          h: Math.random() * 28 + 20,\n          s: Math.random() * 0.4 + 0.6,\n          l: 1\n        },\n        position: vec2.add(vec2.create(), source, vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n        velocity: vec2.scale(vec2.create(), vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * (this.options.maxSparkVelocity - this.options.minSparkVelocity) + this.options.minSparkVelocity),\n        heatCurrent: 0,\n        lastAngleChangeTime: 0,\n        glow: (Math.random() * 0.8) + 0.2,\n        flickerSpeed: Math.random(),\n        life: life,\n        lifeTotal: this.options.maxSparkLife\n      });\n    }\n\n    // 'this' will be the Spark object itself.\n    sparkOnFrame(demo) {\n      var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n      if (ran > CHANGE_DIR_TIME_MAX) {\n        var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n        var matrix = mat2.create();\n        mat2.rotate(matrix, matrix, angle);\n        vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n        this.options.lastAngleChangeTime = demo.lastTime;\n      }\n\n      this.options.heatCurrent += (Math.random());\n      this.options.life -= demo.elapsed;\n      this.options.color.l = (this.options.life / this.options.lifeTotal) * this.options.glow;\n      this.options.lifeRatio = this.options.life / this.options.lifeTotal;\n\n      var nextPos = vec2.scaleAndAdd(vec2.create(), this.position, this.options.velocity, demo.elapsed);\n      this.next(nextPos);\n\n      if (this.options.life < 0 ||\n          nextPos.y > demo.canvas.height ||\n          nextPos.x < 0 ||\n          nextPos.y < 0 ||\n          nextPos.x > demo.canvas.width) {\n        this.reset();\n      }\n    }\n  }\n\n  return Embers;\n\n}));\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n  // still looks smooth.\n  next(pos) {\n    if (!pos)\n    {\n      return;\n    }\n\n    this.points = this.points || [];\n\n    var delta = vec2.sub(vec2.create(), pos, this.position);\n    var deltaNorm = vec2.normalize(vec2.create(), delta);\n    var len = vec2.len(delta);\n\n    for (var i = 1; i < len; i += 1.0)\n    {\n      var tmp = vec2.create();\n      var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n      this.points.push(p);\n    }\n\n    this.points.push(pos);\n\n    this.position = pos;\n\n    while (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      var curLen = 0;\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n","const DEFAULT_WIDTH = 800;\nconst DEFAULT_HEIGHT = 800 / 1.618;\n\nclass ComponentBase {\n  constructor(canvas, options, id) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n\n    this.options = options || {};\n    this.options.fillCanvas = this.options.fillCanvas === false ? false : true;\n    this.lastTime = 0;\n\n    if (!this.options.fillCanvas) {\n      this.canvasTargetWidth = this.width = this.options.width || DEFAULT_WIDTH;\n      this.canvasTargetHeight = this.height = this.options.width || DEFAULT_HEIGHT;\n    } else {\n      setTimeout(this.resizeHandler.bind(this), 250);\n    }\n\n    window.addEventListener('resize', this.resizeHandler.bind(this));\n    this.lastScrollTop = window.scrollY;\n\n    window.addEventListener('scroll', this._scrollHandler.bind(this));\n\n    canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n    canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n    canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n    canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n    canvas.setAttribute('width', DEFAULT_WIDTH);\n    canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n    if (id) {\n      canvas.setAttribute('id', id);\n    }\n\n    window.requestAnimationFrame(this._onFrameFirstHandler.bind(this));\n  }\n\n  resizeHandler(event) {\n    if (this.options.fillCanvas) {\n      var w = window.innerWidth;\n      var h = window.innerHeight;\n\n      this.canvas.width = this.canvas.style.width = this.canvasTargetWidth = this.width = w;\n      this.canvas.height = this.canvas.style.height = this.canvasTargetHeight = this.height = h;\n    } else {\n      var i = Math.min(800, window.innerWidth);\n\n      this.canvas.style.width = this.canvasTargetWidth = i;\n      this.canvas.style.height = this.canvasTargetHeight = i / 1.618;\n    }\n\n    this.resize();\n  }\n\n  _scrollHandler(event) {\n    var deltaY = window.scrollY - this.lastScrollTop;\n    this.lastScrollTop = window.scrollY;\n    this.scrollHandler(deltaY);\n  }\n\n  scrollHandler(deltaY) {\n    console.log('Scrolling!', deltaY);\n  }\n\n  resize() {\n    console.log('Resized!', this.canvasTargetWidth, this.canvasTargetHeight);\n  }\n\n  onMouseMoveHandler() {\n    // noop\n  }\n\n  onMouseOutHandler() {\n    // noop\n  }\n\n  onTouchStartHandler() {\n    // noop\n  }\n\n  onTouchMoveHandler() {\n    // noop\n  }\n\n  get debugText() {\n    return this.canvas.width + ', ' + this.canvas.height + ' FPS: ' + Math.round(1 / this.elapsed);\n  }\n\n  _onFrameFirstHandler(timestamp) {\n    this.lastTime = timestamp;\n    window.requestAnimationFrame(this._onFrameHandler.bind(this));\n  }\n\n  _onFrameHandler(timestamp) {\n    window.requestAnimationFrame(this._onFrameHandler.bind(this));\n\n    this.elapsed = (timestamp - this.lastTime) / 1000;\n    this.lastTime = timestamp;\n\n    this.onFrameHandler(this.elapsed);\n\n    if (this.options.debug) {\n      this.ctx.font = '12px Georgia white';\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillText(this.debugText, 10, 50);\n    }\n  }\n}\n\nexport default ComponentBase;\n","export function ran(min, max) {\n  return Math.random() * (max - min) + min;\n};\n\nexport function ranItem(arr) {\n  return arr[Math.floor(ran(0, arr.length - 0.000001))];\n};\n\nexport const Sides = {\n  LEFT: 1,\n  TOP: 2,\n  RIGHT: 3,\n  BOTTOM: 4,\n  ran: function() {\n    return Math.floor(ran(1, 4.99));\n  }\n};\n\nexport function isAbove(p1, p2) {\n  return p1.y < p2.y;\n}\nexport function isBelow(p1, p2) {\n  return p1.y > p2.y;\n}\nexport function isLeft(p1, p2) {\n  return p1.x < p2.x;\n}\nexport function isRight(p1, p2) {\n  return p1.x > p2.x;\n}\nexport function reverseOf(dir) {\n  return (((dir - 1) + 2) % 4) + 1;\n} // Opposite of LEFT (1) is RIGHT (3) etc.\nexport function toward(p1, p2) {\n  var dir = [];\n  if (isAbove(p1, p2)) dir.push(4);\n  if (isBelow(p1, p2)) dir.push(2);\n  if (isLeft(p1, p2)) dir.push(3);\n  if (isRight(p1, p2)) dir.push(1);\n  return dir;\n}\n\nexport function vecFor(side) {\n  if (side == Sides.LEFT) return new paper.Point(-1, 0);\n  if (side == Sides.RIGHT) return new paper.Point(1, 0);\n  if (side == Sides.TOP) return new paper.Point(0, -1);\n  if (side == Sides.BOTTOM) return new paper.Point(0, 1);\n}\n\nexport function getRandomPointFor(side, bounds) {\n  let x = 0;\n  x = side == Sides.RIGHT ? bounds.right : x;\n  x = side == Sides.TOP || side == Sides.BOTTOM ? ran(0, bounds.right) : x;\n\n  let y = 0;\n  y = side == Sides.BOTTOM ? bounds.bottom : y;\n  y = side == Sides.LEFT || side == Sides.RIGHT ? ran(0, bounds.bottom) : y;\n\n  return new paper.Point(x, y);\n}\n\nexport function hsvToRgb(h, s, v) {\n  var i;\n  var f;\n  var p;\n  var q;\n  var t;\n  var r;\n  var g;\n  var b;\n  if (s == 0) {\n    // achromatic (grey)\n    r = g = b = v;\n  } else {\n    h /= 60; // sector 0 to 5\n    i = Math.floor(h);\n    f = h - i; // factorial part of h\n    p = v * (1 - s);\n    q = v * (1 - s * f);\n    t = v * (1 - s * (1 - f));\n    switch (i) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n      default:\n        r = v;\n        g = p;\n        b = q;\n        break;\n    }\n  }\n\n  return {\n    r: r,\n    g: g,\n    b: b\n  };\n}\n\nexport default {\n  ran: ran,\n  ranItem: ranItem,\n  Sides: Sides,\n  isAbove: isAbove,\n  isBelow: isBelow,\n  isLeft: isLeft,\n  isRight: isRight,\n  reverseOf: reverseOf,\n  toward: toward,\n  vecFor: vecFor,\n  hsvToRgb: hsvToRgb,\n  getRandomPointFor: getRandomPointFor\n};\n","import Lib from '../lib/Lib.js';\nimport ComponentBase from '../lib/core/ComponentBase.js';\nimport Spark from '../lib/gx/Spark.js';\nimport util from '../lib/util/util.js';\n\n/*============================================\n * Constants\n *============================================*/\nconst SPARK_COUNT = 100;              // Maximum number of sparks to display simultaneously\nconst SPARK_MAX_SIZE = 3.4;\nconst SPARK_MIN_SIZE = 1;\nconst SPARK_MAX_VELOCITY = 70;\nconst SPARK_MIN_VELOCITY = 20;\nconst SPARK_SOURCE_RADIUS = 40;       // Spark source radius in pixels\nconst CHANGE_DIR_TIME_MAX = 5000;     // The maximum time to wait between changing directions\nconst SPARK_RESOLUTION = 10;          // The number of tail segments of the spark.\nconst SPARK_MAX_TAIL_LENGTH = 20;\nconst SPARK_MAX_LIFE_S = 10;\n\n/*============================================\n * The demo JSX component\n *============================================*/\nclass Embers extends ComponentBase {\n  constructor(canvas, options) {\n    super(canvas, options);\n\n    this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n    this.options.maxSparkSize = this.options.maxSparkSize || SPARK_MAX_SIZE;\n    this.options.minSparkSize = this.options.minSparkSize || SPARK_MIN_SIZE;\n    this.options.maxSparkVelocity = this.options.maxSparkVelocity || SPARK_MAX_VELOCITY;\n    this.options.minSparkVelocity = this.options.minSparkVelocity || SPARK_MIN_VELOCITY;\n    this.options.maxTailLength = this.options.maxTailLength || SPARK_MAX_TAIL_LENGTH;\n    this.options.sparkCount = this.options.sparkCount || SPARK_COUNT;\n    this.options.maxSparkLife = this.options.maxSparkLife || SPARK_MAX_LIFE_S;\n\n    this.sparkSource = this.options.sparkSource ? this.options.sparkSource : new vec2.fromValues(this.width / 2, this.height / 5);\n\n    this.sparks = [];\n\n    for (var i = 0; i < this.options.sparkCount; i++) {\n      this.sparks.push(new Spark({\n        pathRedraw: this.pathRedraw.bind(this),\n        sparkResolution: 4\n      }));\n    }\n  }\n\n  pathRedraw(spark, start, end, curLen, ratio, elapsed, context) {\n    ratio =  1 - (curLen / this.options.maxTailLength);\n\n    var rgb = util.hsvToRgb(spark.options.color.h, spark.options.color.s, spark.options.color.l);\n\n    context.strokeStyle = 'rgba(' + ~~(rgb.r * 256) + ',' + ~~(rgb.g * 256) + ',' + ~~(rgb.b) * 256 + ',' + (ratio * spark.options.lifeRatio) + ')';\n    context.lineWidth = spark.options.size * ratio;\n\n    context.beginPath();\n    context.moveTo(start[0], start[1]);\n    context.lineTo(end[0], end[1]);\n    context.stroke();\n  }\n\n  onFrameHandler(elapsed) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.sparks.forEach(spark => {\n      if (!spark.sparking) {\n        if (Math.random() > 0.95)\n        {\n          this.startSpark(spark);\n        }\n        else return;\n      }\n\n      this.sparkOnFrame.call(spark, this);\n\n      spark.onFrame(this.elapsed, this.ctx);\n    });\n  }\n\n  scrollHandler(deltaY) {\n    var trans = vec2.fromValues(0, -deltaY);\n    this.sparks.forEach(spark => {\n      if (spark.sparking) {\n        spark.points = spark.points.map(p => vec2.add(vec2.create(), p, trans));\n\n        vec2.add(spark.position, spark.position, trans);\n      }\n    });\n  }\n\n  startSpark(spark) {\n    var velAngle = Math.random() - .5 - (Math.PI / 2);\n    var sourceAngle = Math.random() * Math.PI * 2;\n    var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n    var life = (Math.random() * this.options.maxSparkLife/2) + this.options.maxSparkLife / 2;\n    var source = this.sparkSource;\n\n    if (source.target) {\n      var boundingRect = source.target.getBoundingClientRect(); // Get rect ya'll\n      var xOffset = 0;\n      var yOffset = 0;\n\n      if (source.offset && source.offset.x) {\n        xOffset = source.offset.x.indexOf('%') != -1 ? source.target[source.widthProp] * (parseFloat(source.offset.x) / 100) : source.offset.x;\n      }\n      if (source.offset && source.offset.y) {\n        yOffset = source.offset.y.indexOf('%') != -1 ? source.target[source.heightProp] * (parseFloat(source.offset.y) / 100) : source.offset.y;\n      }\n\n      source = vec2.fromValues(xOffset, Math.min(yOffset + boundingRect.top, window.innerHeight));\n    } else {\n      throw 'Huge error';\n    }\n\n    spark.spark({\n      type: 2,\n      sparkResolution: SPARK_RESOLUTION,\n      size: (Math.random() * (this.options.maxSparkSize - this.options.minSparkSize)) + this.options.minSparkSize,\n      color: {\n        h: Math.random() * 28 + 20,\n        s: Math.random() * 0.4 + 0.6,\n        l: 1\n      },\n      position: vec2.add(vec2.create(), source, vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n      velocity: vec2.scale(vec2.create(), vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * (this.options.maxSparkVelocity - this.options.minSparkVelocity) + this.options.minSparkVelocity),\n      heatCurrent: 0,\n      lastAngleChangeTime: 0,\n      glow: (Math.random() * 0.8) + 0.2,\n      flickerSpeed: Math.random(),\n      life: life,\n      lifeTotal: this.options.maxSparkLife\n    });\n  }\n\n  // 'this' will be the Spark object itself.\n  sparkOnFrame(demo) {\n    var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n    if (ran > CHANGE_DIR_TIME_MAX) {\n      var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n      var matrix = mat2.create();\n      mat2.rotate(matrix, matrix, angle);\n      vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n      this.options.lastAngleChangeTime = demo.lastTime;\n    }\n\n    this.options.heatCurrent += (Math.random());\n    this.options.life -= demo.elapsed;\n    this.options.color.l = (this.options.life / this.options.lifeTotal) * this.options.glow;\n    this.options.lifeRatio = this.options.life / this.options.lifeTotal;\n\n    var nextPos = vec2.scaleAndAdd(vec2.create(), this.position, this.options.velocity, demo.elapsed);\n    this.next(nextPos);\n\n    if (this.options.life < 0 ||\n        nextPos.y > demo.canvas.height ||\n        nextPos.x < 0 ||\n        nextPos.y < 0 ||\n        nextPos.x > demo.canvas.width) {\n      this.reset();\n    }\n  }\n}\n\nexport default Embers;\n"],"sourceRoot":"/source/"}