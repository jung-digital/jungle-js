{"version":3,"sources":["Embers.js","src/lib/gx/Spark.js","src/lib/Lib.js","src/lib/core/ComponentBase.js","src/embers/Embers.js"],"names":[],"mappings":"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","file":"Embers.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('shared/util/util')) :\n  typeof define === 'function' && define.amd ? define(['shared/util/util'], factory) :\n  global.Embers = factory(global.util)\n}(this, function (util) { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark\n    next(pos) {\n      this.position = pos;\n\n      this.points = this.points || [];\n      this.points.push(pos);\n\n      if (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkLength = options.sparkLength || 200; // Pixel length of the spark\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var Lib_js = new Lib();\n\n  const DEFAULT_WIDTH = 800;\n  const DEFAULT_HEIGHT = 800 / 1.618;\n\n  class ComponentBase {\n    constructor(canvas, id) {\n      this.canvas = canvas;\n      this.ctx = canvas.getContext('2d');\n\n      this.lastTime = 0;\n\n      this.canvasTargetWidth = this.width = DEFAULT_WIDTH;\n      this.canvasTargetHeight = this.height = DEFAULT_HEIGHT;\n\n      window.addEventListener('resize', this.resizeHandler.bind(this));\n\n      canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n      canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n      canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n      canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n      canvas.setAttribute('width', DEFAULT_WIDTH);\n      canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n      if (id) {\n        canvas.setAttribute('id', id);\n      }\n\n      window.requestAnimationFrame(this.onFrameFirst.bind(this));\n    }\n\n    resizeHandler(event) {\n      var i = Math.min(800, window.innerWidth);\n\n      canvas.style.width = this.state.canvasTargetWidth = i;\n      canvas.style.height = this.state.canvasTargetHeight = i / 1.618;\n\n      this.resize();\n    }\n\n    resize() {\n      console.log('Resized!', this.state.canvasTargetWidth, this.state.canvasTargetHeight);\n    }\n\n    onMouseMoveHandler() {\n      // noop\n    }\n\n    onMouseOutHandler() {\n      // noop\n    }\n\n    onTouchStartHandler() {\n      // noop\n    }\n\n    onTouchMoveHandler() {\n      // noop\n    }\n\n    onFrameFirst(timestamp) {\n      this.lastTime = timestamp;\n      window.requestAnimationFrame(this.onFrame.bind(this));\n    }\n\n    onFrameHandler(timestamp) {\n      if (!this.lastTime) {\n        this.lastTime = timestamp;\n        this.elapsed = 0.01;\n      } else {\n        this.elapsed = (timestamp - this.lastTime) / 1000;\n      }\n    }\n  }\n\n  /*============================================\n   * Constants\n   *============================================*/\n  const SPARKS = 500;               // Maximum number of sparks to display simulataneously\n  const WIDTH = 800;                // Width of canvas\n  const HEIGHT = 800 / 1.61;        // Height of canvas,\n  const SPARK_SOURCE_RADIUS = 50;   // Spark source radius in pixels\n  const CHANGE_DIR_TIME_MAX = 5000; // The maximum time to wait between changing directions   \n\n  /*============================================\n   * The demo JSX component\n   *============================================*/\n  class Embers extends ComponentBase {\n    constructor(canvas) {\n      super(canvas);\n\n      this.hue = 0;\n\n      this.sparkSource = new gl.vec2.fromValues(WIDTH / 2, HEIGHT / 5);\n\n      this.sparks = [];\n\n      for (var i = 0; i < SPARKS; i++) {\n        this.sparks.push(new Spark({\n          pathRedraw: this.pathRedraw,\n          sparkResolution: 4\n        }));\n      }\n    }\n\n    pathRedraw(spark, start, end, ratio, elapsed, context) {\n      ratio = 1 - ratio;\n\n      context.strokeStyle = 'rgba(' + ~~(spark.options.color.r * 256) + ',' + ~~(spark.options.color.g * 256) + ',' + ~~(spark.options.color.b) * 256 + ',' + ratio + ')';\n      context.lineWidth = spark.options.size * ratio;\n\n      context.beginPath();\n      context.moveTo(start[0], start[1]);\n      context.lineTo(end[0], end[1]);\n      context.stroke();\n    }\n\n    onFrame(timestamp) {\n      this.ctx.clearRect(0, 0, this.state.WIDTH, this.state.HEIGHT);\n      this.elapsed = (timestamp - this.lastTime) / 1000;\n      this.lastTime = timestamp;\n\n      this.hue = Math.random() * Math.random() * 60;\n\n      this.sparks.forEach(spark => {\n        if (!spark.sparking) {\n          this.startSpark(spark);\n        }\n\n        this.sparkOnFrame.call(spark, this);\n\n        spark.onFrame(this.elapsed, this.ctx);\n      });\n\n      window.requestAnimationFrame(this.onFrame.bind(this));\n    }\n\n    startSpark(spark) {\n      var velAngle = Math.random() - .5 - (Math.PI / 2);\n      var sourceAngle = Math.random() * Math.PI * 2;\n      var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n      var rgb = util.hsvToRgb(this.hue, 1, 0.8);\n\n      spark.spark({\n        type: 2,\n        size: (Math.random() * 2) + 1,\n        color: rgb,\n        position: gl.vec2.add(gl.vec2.create(), this.sparkSource, gl.vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n        velocity: gl.vec2.scale(gl.vec2.create(), gl.vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * 150 + 20),\n        heatCurrent: 0,\n        lastAngleChangeTime: 0,\n        life: (Math.random() * 4 + 2)\n      });\n    }\n\n    // 'this' will be the Spark object itself.\n    sparkOnFrame(demo) {\n      var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n      if (ran > CHANGE_DIR_TIME_MAX) {\n        var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n        var matrix = gl.mat2.create();\n        gl.mat2.rotate(matrix, matrix, angle);\n        gl.vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n        this.options.lastAngleChangeTime = demo.lastTime;\n      }\n\n      this.options.heatCurrent += (Math.random());\n      this.options.life -= demo.elapsed;\n\n      var nextPos = gl.vec2.scaleAndAdd(gl.vec2.create(), this.position, this.options.velocity, demo.elapsed);\n      this.next(nextPos);\n\n      if (this.options.life < 0 || nextPos.y > HEIGHT + 50 || nextPos.x < -50 || nextPos.y < -50 || nextPos.x > WIDTH + 50) {\n        this.reset();\n      }\n    }\n\n    onMouseMoveHandler(event) {\n      var rect = this.canvas.getBoundingClientRect();\n      var scale = WIDTH / this.state.canvasTargetWidth;\n\n      this.sparkSource = gl.vec2.fromValues((event.clientX - rect.left) * scale, (event.clientY - rect.top) * scale);\n    }\n\n    onTouchMoveHandler(event) {\n      event.preventDefault();\n\n      var rect = this.canvas.getBoundingClientRect();\n      var scale = WIDTH / this.state.canvasTargetWidth;\n\n      this.sparkSource = gl.vec2.fromValues((event.touches[0].clientX - rect.left) * scale, (event.touches[0].clientY - rect.top) * scale);\n    }\n  }\n\n  return Embers;\n\n}));\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark\n  next(pos) {\n    this.position = pos;\n\n    this.points = this.points || [];\n    this.points.push(pos);\n\n    if (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkLength = options.sparkLength || 200; // Pixel length of the spark\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n","const DEFAULT_WIDTH = 800;\nconst DEFAULT_HEIGHT = 800 / 1.618;\n\nclass ComponentBase {\n  constructor(canvas, id) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n\n    this.lastTime = 0;\n\n    this.canvasTargetWidth = this.width = DEFAULT_WIDTH;\n    this.canvasTargetHeight = this.height = DEFAULT_HEIGHT;\n\n    window.addEventListener('resize', this.resizeHandler.bind(this));\n\n    canvas.addEventListener('mousemove', this.onMouseMoveHandler.bind(this));\n    canvas.addEventListener('mouseout', this.onMouseOutHandler.bind(this));\n    canvas.addEventListener('touchstart', this.onTouchStartHandler.bind(this));\n    canvas.addEventListener('touchmove', this.onTouchMoveHandler.bind(this));\n\n    canvas.setAttribute('width', DEFAULT_WIDTH);\n    canvas.setAttribute('height', DEFAULT_HEIGHT);\n\n    if (id) {\n      canvas.setAttribute('id', id);\n    }\n\n    window.requestAnimationFrame(this.onFrameFirst.bind(this));\n  }\n\n  resizeHandler(event) {\n    var i = Math.min(800, window.innerWidth);\n\n    canvas.style.width = this.state.canvasTargetWidth = i;\n    canvas.style.height = this.state.canvasTargetHeight = i / 1.618;\n\n    this.resize();\n  }\n\n  resize() {\n    console.log('Resized!', this.state.canvasTargetWidth, this.state.canvasTargetHeight);\n  }\n\n  onMouseMoveHandler() {\n    // noop\n  }\n\n  onMouseOutHandler() {\n    // noop\n  }\n\n  onTouchStartHandler() {\n    // noop\n  }\n\n  onTouchMoveHandler() {\n    // noop\n  }\n\n  onFrameFirst(timestamp) {\n    this.lastTime = timestamp;\n    window.requestAnimationFrame(this.onFrame.bind(this));\n  }\n\n  onFrameHandler(timestamp) {\n    if (!this.lastTime) {\n      this.lastTime = timestamp;\n      this.elapsed = 0.01;\n    } else {\n      this.elapsed = (timestamp - this.lastTime) / 1000;\n    }\n  }\n}\n\nexport default ComponentBase;\n","import Lib from '../lib/Lib.js';\nimport ComponentBase from '../lib/core/ComponentBase.js';\nimport Spark from '../lib/gx/Spark.js';\nimport util from '../shared/util/util';\n\n/*============================================\n * Constants\n *============================================*/\nconst SPARKS = 500;               // Maximum number of sparks to display simulataneously\nconst WIDTH = 800;                // Width of canvas\nconst HEIGHT = 800 / 1.61;        // Height of canvas,\nconst SPARK_SOURCE_RADIUS = 50;   // Spark source radius in pixels\nconst CHANGE_DIR_TIME_MAX = 5000; // The maximum time to wait between changing directions   \n\n/*============================================\n * The demo JSX component\n *============================================*/\nclass Embers extends ComponentBase {\n  constructor(canvas) {\n    super(canvas);\n\n    this.hue = 0;\n\n    this.sparkSource = new gl.vec2.fromValues(WIDTH / 2, HEIGHT / 5);\n\n    this.sparks = [];\n\n    for (var i = 0; i < SPARKS; i++) {\n      this.sparks.push(new Spark({\n        pathRedraw: this.pathRedraw,\n        sparkResolution: 4\n      }));\n    }\n  }\n\n  pathRedraw(spark, start, end, ratio, elapsed, context) {\n    ratio = 1 - ratio;\n\n    context.strokeStyle = 'rgba(' + ~~(spark.options.color.r * 256) + ',' + ~~(spark.options.color.g * 256) + ',' + ~~(spark.options.color.b) * 256 + ',' + ratio + ')';\n    context.lineWidth = spark.options.size * ratio;\n\n    context.beginPath();\n    context.moveTo(start[0], start[1]);\n    context.lineTo(end[0], end[1]);\n    context.stroke();\n  }\n\n  onFrame(timestamp) {\n    this.ctx.clearRect(0, 0, this.state.WIDTH, this.state.HEIGHT);\n    this.elapsed = (timestamp - this.lastTime) / 1000;\n    this.lastTime = timestamp;\n\n    this.hue = Math.random() * Math.random() * 60;\n\n    this.sparks.forEach(spark => {\n      if (!spark.sparking) {\n        this.startSpark(spark);\n      }\n\n      this.sparkOnFrame.call(spark, this);\n\n      spark.onFrame(this.elapsed, this.ctx);\n    });\n\n    window.requestAnimationFrame(this.onFrame.bind(this));\n  }\n\n  startSpark(spark) {\n    var velAngle = Math.random() - .5 - (Math.PI / 2);\n    var sourceAngle = Math.random() * Math.PI * 2;\n    var sourceDistance = Math.random() * SPARK_SOURCE_RADIUS;\n    var rgb = util.hsvToRgb(this.hue, 1, 0.8);\n\n    spark.spark({\n      type: 2,\n      size: (Math.random() * 2) + 1,\n      color: rgb,\n      position: gl.vec2.add(gl.vec2.create(), this.sparkSource, gl.vec2.fromValues(Math.cos(sourceAngle) * sourceDistance, Math.sin(sourceAngle) * sourceDistance)),\n      velocity: gl.vec2.scale(gl.vec2.create(), gl.vec2.fromValues(Math.cos(velAngle), Math.sin(velAngle)), Math.random() * 150 + 20),\n      heatCurrent: 0,\n      lastAngleChangeTime: 0,\n      life: (Math.random() * 4 + 2)\n    });\n  }\n\n  // 'this' will be the Spark object itself.\n  sparkOnFrame(demo) {\n    var ran = (Math.random() * CHANGE_DIR_TIME_MAX) + (demo.lastTime - this.options.lastAngleChangeTime);\n\n    if (ran > CHANGE_DIR_TIME_MAX) {\n      var angle = (Math.random() * (3.141 / 3)) - (3.141 / 6);\n      var matrix = gl.mat2.create();\n      gl.mat2.rotate(matrix, matrix, angle);\n      gl.vec2.transformMat2(this.options.velocity, this.options.velocity, matrix);\n      this.options.lastAngleChangeTime = demo.lastTime;\n    }\n\n    this.options.heatCurrent += (Math.random());\n    this.options.life -= demo.elapsed;\n\n    var nextPos = gl.vec2.scaleAndAdd(gl.vec2.create(), this.position, this.options.velocity, demo.elapsed);\n    this.next(nextPos);\n\n    if (this.options.life < 0 || nextPos.y > HEIGHT + 50 || nextPos.x < -50 || nextPos.y < -50 || nextPos.x > WIDTH + 50) {\n      this.reset();\n    }\n  }\n\n  onMouseMoveHandler(event) {\n    var rect = this.canvas.getBoundingClientRect();\n    var scale = WIDTH / this.state.canvasTargetWidth;\n\n    this.sparkSource = gl.vec2.fromValues((event.clientX - rect.left) * scale, (event.clientY - rect.top) * scale);\n  }\n\n  onTouchMoveHandler(event) {\n    event.preventDefault();\n\n    var rect = this.canvas.getBoundingClientRect();\n    var scale = WIDTH / this.state.canvasTargetWidth;\n\n    this.sparkSource = gl.vec2.fromValues((event.touches[0].clientX - rect.left) * scale, (event.touches[0].clientY - rect.top) * scale);\n  }\n}\n\nexport default Embers;\n"],"sourceRoot":"/source/"}