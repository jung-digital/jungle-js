{"version":3,"sources":["Lib.min.js","/source/Lib.js","/source/src/lib/gx/Spark.js","/source/src/lib/Lib.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","Lib","this","Spark","options","id","pathRedraw","sparkResolution","paths","sparking","value","a","onFrameCallback","velocity","position","points","undefined","pos","delta","vec2","sub","create","deltaNorm","normalize","crbeate","len","tmp","p","add","scale","push","shift","elapsed","context","call","updateTail","curLen","start","end","lib_Lib"],"mappings":"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","file":"Lib.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Lib = factory()\n}(this, function () { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n    // still looks smooth.\n    next(pos) {\n      if (!pos) {\n        return;\n      }\n\n      this.points = this.points || [];\n\n      var delta = vec2.sub(vec2.create(), pos, this.position);\n      var deltaNorm = vec2.normalize(vec2.crbeate(), delta);\n      var len = vec2.len(delta);\n\n      for (var i = 1; i < len; i += 1.0) {\n        var tmp = vec2.create();\n        var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n        this.points.push(p);\n      }\n\n      this.points.push(pos);\n\n      this.position = pos;\n\n      while (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        var curLen = 0;\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var lib_Lib = new Lib();\n\n  return lib_Lib;\n\n}));\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n  // still looks smooth.\n  next(pos) {\n    if (!pos) {\n      return;\n    }\n\n    this.points = this.points || [];\n\n    var delta = vec2.sub(vec2.create(), pos, this.position);\n    var deltaNorm = vec2.normalize(vec2.crbeate(), delta);\n    var len = vec2.len(delta);\n\n    for (var i = 1; i < len; i += 1.0) {\n      var tmp = vec2.create();\n      var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n      this.points.push(p);\n    }\n\n    this.points.push(pos);\n\n    this.position = pos;\n\n    while (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      var curLen = 0;\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n"],"sourceRoot":"/source/"}