{"version":3,"sources":["Lib.js","src/lib/gx/Spark.js","src/lib/Lib.js"],"names":[],"mappings":";;;;AAAA,AAAC,CAAA,UAAU,MAAM,EAAE,OAAO,EAAE;AAC1B,SAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,WAAW,GAAG,MAAM,CAAC,OAAO,GAAG,OAAO,EAAE,GACzF,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC,GAC5D,MAAM,CAAC,GAAG,GAAG,OAAO,EAAE,CAAA;CACvB,CAAA,CAAC,IAAI,EAAE,YAAY;AAAE,cAAY,CAAC;;;;;;;MCC7B,KAAA;iBAAA,KAAA;;aAEC,iBAAG;AACN,YAAA,CAAK,QAAA,GAAW,KAAA,CAAA;OACpB;;;aAEO,eAAC,OAAA,EAAS;AACb,YAAI,IAAA,CAAK,QAAA,EAAU;AACjB,iBAAA;SACN;;;AAGI,aAAK,IAAI,CAAA,IAAK,OAAA,EAAS;AACrB,cAAA,CAAK,OAAA,CAAQ,CAAA,CAAA,GAAK,OAAA,CAAQ,CAAA,CAAA,CAAA;SAChC;;;AAGI,YAAA,CAAK,eAAA,GAAkB,OAAA,CAAQ,eAAA,CAAA;AAC/B,YAAA,CAAK,QAAA,GAAW,OAAA,CAAQ,QAAA,CAAA;;AAExB,YAAA,CAAK,QAAA,GAAW,IAAA,CAAA;AAChB,YAAA,CAAK,QAAA,GAAW,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAA;;AAE7B,YAAA,CAAK,MAAA,GAAS,IAAA,CAAK,OAAA,CAAQ,QAAA,GAAW,CAAC,IAAA,CAAK,OAAA,CAAQ,QAAA,CAAA,GAAY,SAAA,CAAA;OACpE;;;;;;aAIM,cAAC,GAAA,EAAK;AACR,YAAI,CAAC,GAAA,EAAK;AACR,iBAAA;SACN;;AAEI,YAAA,CAAK,MAAA,GAAS,IAAA,CAAK,MAAA,IAAU,EAAA,CAAA;;AAE7B,YAAI,KAAA,GAAQ,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,MAAA,EAAA,EAAU,GAAA,EAAK,IAAA,CAAK,QAAA,CAAA,CAAA;AAC9C,YAAI,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,OAAA,EAAA,EAAW,KAAA,CAAA,CAAA;AAC/C,YAAI,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,KAAA,CAAA,CAAA;;AAEnB,aAAK,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,CAAA,IAAK,GAAA,EAAK;AACjC,cAAI,GAAA,GAAM,IAAA,CAAK,MAAA,EAAA,CAAA;AACf,cAAI,CAAA,GAAI,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,IAAA,CAAK,KAAA,CAAM,GAAA,EAAK,SAAA,EAAW,CAAA,CAAA,EAAI,IAAA,CAAK,QAAA,CAAA,CAAA;AAC1D,cAAA,CAAK,MAAA,CAAO,IAAA,CAAK,CAAA,CAAA,CAAA;SACvB;;AAEI,YAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAA,CAAA,CAAA;;AAEjB,YAAA,CAAK,QAAA,GAAW,GAAA,CAAA;;AAEhB,eAAO,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,IAAA,CAAK,eAAA,EAAiB;AAChD,cAAA,CAAK,MAAA,CAAO,KAAA,EAAA,CAAA;SAClB;OACA;;;aAES,iBAAC,OAAA,EAAS,OAAA,EAAS;AACxB,YAAI,IAAA,CAAK,QAAA,EAAU;AACjB,cAAI,IAAA,CAAK,eAAA,EAAiB;AACxB,gBAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,IAAA,EAAM,OAAA,EAAS,OAAA,CAAA,CAAA;WACjD;;AAEM,cAAA,CAAK,UAAA,CAAW,OAAA,EAAS,OAAA,CAAA,CAAA;SAC/B;OACA;;;aAEY,oBAAC,OAAA,EAAS,OAAA,EAAS;;;AAG3B,YAAI,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG;AAC1B,cAAI,MAAA,GAAS,CAAA,CAAA;AACb,eAAK,IAAI,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA,GAAS,CAAA,EAAG,CAAA,EAAA,EAAK;AAC/C,gBAAI,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,MAAA,IAAU,CAAA,GAAI,CAAA,CAAA,CAAA,CAAA;AAClD,gBAAI,GAAA,GAAM,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,MAAA,IAAU,CAAA,GAAI,CAAA,CAAA,CAAA,CAAA;;AAEhD,kBAAA,IAAU,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,MAAA,EAAA,EAAU,GAAA,EAAK,KAAA,CAAA,CAAA,CAAA;;;AAGhD,gBAAA,CAAK,UAAA,CAAW,IAAA,EAAM,KAAA,EAAO,GAAA,EAAK,MAAA,EAAQ,CAAA,IAAK,IAAA,CAAK,eAAA,GAAkB,CAAA,CAAA,EAAI,OAAA,EAAS,OAAA,CAAA,CAAA;WAC3F;SACA;OACA;;;;;AAGa,aAlFP,KAAA,CAkFQ,OAAA,EAAS;4BAlFjB,KAAA;;AAmFF,UAAA,CAAK,EAAA,GAAK,OAAA,CAAQ,EAAA,IAAM,CAAC,CAAA,CAAA;AACzB,UAAA,CAAK,UAAA,GAAa,OAAA,CAAQ,UAAA,CAAA;;AAE1B,UAAA,CAAK,eAAA,GAAkB,OAAA,CAAQ,eAAA,IAAmB,EAAA,CAAA;;AAElD,UAAA,CAAK,OAAA,GAAU,OAAA,CAAA;;AAEf,UAAA,CAAK,KAAA,GAAQ,EAAA,CAAA;;AAEb,UAAA,CAAK,QAAA,GAAW,KAAA,CAAA;KACpB;;WA7FM,KAAA;;;MCHA,GAAA,GACO,SADP,GAAA,GACU;0BADV,GAAA;;AAEF,QAAA,CAAK,KAAA,GAAQ,KAAA,CAAA;GACjB;;AALA,MAAA,OAAA,GAQe,IAAI,GAAA,EAAA,CAAA;;AF2GjB,SAAO,OAAO,CAAC;CAEhB,CAAC,CAAE","file":"Lib.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Lib = factory()\n}(this, function () { 'use strict';\n\n  /*============================================\n   * A spark represents a sequence of shapes that\n   * move along a provided path.\n   *============================================*/\n\n  class Spark {\n\n    reset() {\n      this.sparking = false;\n    }\n\n    spark(options) {\n      if (this.sparking) {\n        return;\n      }\n\n      // Merge with current options\n      for (var a in options) {\n        this.options[a] = options[a];\n      }\n\n      // TODO do not duplicate variable names, reference via 'this.options.blah'\n      this.onFrameCallback = options.onFrameCallback;\n      this.velocity = options.velocity;\n\n      this.sparking = true;\n      this.position = this.options.position;\n\n      this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n    }\n\n    // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n    // still looks smooth.\n    next(pos) {\n      if (!pos) {\n        return;\n      }\n\n      this.points = this.points || [];\n\n      var delta = vec2.sub(vec2.create(), pos, this.position);\n      var deltaNorm = vec2.normalize(vec2.crbeate(), delta);\n      var len = vec2.len(delta);\n\n      for (var i = 1; i < len; i += 1.0) {\n        var tmp = vec2.create();\n        var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n        this.points.push(p);\n      }\n\n      this.points.push(pos);\n\n      this.position = pos;\n\n      while (this.points.length > this.sparkResolution) {\n        this.points.shift();\n      }\n    }\n\n    onFrame(elapsed, context) {\n      if (this.sparking) {\n        if (this.onFrameCallback) {\n          this.onFrameCallback.call(this, elapsed, context);\n        }\n\n        this.updateTail(elapsed, context);\n      }\n    }\n\n    updateTail(elapsed, context) {\n      // Go backwards from the end, building up paths and letting the dev manually style them\n      // ensuring that there are this.resolution # of paths.\n      if (this.points.length > 1) {\n        var curLen = 0;\n        for (var i = 0; i < this.points.length - 1; i++) {\n          var start = this.points[this.points.length - (i + 1)];\n          var end = this.points[this.points.length - (i + 2)];\n\n          curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n          // Let dev manually style points based on ratio of start to end\n          this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n        }\n      }\n    }\n\n    // Spark()\n    constructor(options) {\n      this.id = options.id || -1; // index of this spark\n      this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n      this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n      this.options = options;\n\n      this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n      this.sparking = false;\n    }\n  }\n\n  class Lib {\n    constructor() {\n      this.Spark = Spark;\n    }\n  }\n\n  var lib_Lib = new Lib();\n\n  return lib_Lib;\n\n}));\n","/*============================================\n * A spark represents a sequence of shapes that\n * move along a provided path.\n *============================================*/\n\nclass Spark {\n\n  reset() {\n    this.sparking = false;\n  }\n\n  spark(options) {\n    if (this.sparking) {\n      return;\n    }\n\n    // Merge with current options\n    for (var a in options) {\n      this.options[a] = options[a];\n    }\n\n    // TODO do not duplicate variable names, reference via 'this.options.blah'\n    this.onFrameCallback = options.onFrameCallback;\n    this.velocity = options.velocity;\n\n    this.sparking = true;\n    this.position = this.options.position;\n\n    this.points = this.options.position ? [this.options.position] : undefined; // Reset points for manual mode\n  }\n\n  // Manual mode, set the next position of the spark. Insert points if the spark has jumped a great distance so that it\n  // still looks smooth.\n  next(pos) {\n    if (!pos) {\n      return;\n    }\n\n    this.points = this.points || [];\n\n    var delta = vec2.sub(vec2.create(), pos, this.position);\n    var deltaNorm = vec2.normalize(vec2.crbeate(), delta);\n    var len = vec2.len(delta);\n\n    for (var i = 1; i < len; i += 1.0) {\n      var tmp = vec2.create();\n      var p = vec2.add(tmp, vec2.scale(tmp, deltaNorm, i), this.position);\n      this.points.push(p);\n    }\n\n    this.points.push(pos);\n\n    this.position = pos;\n\n    while (this.points.length > this.sparkResolution) {\n      this.points.shift();\n    }\n  }\n\n  onFrame(elapsed, context) {\n    if (this.sparking) {\n      if (this.onFrameCallback) {\n        this.onFrameCallback.call(this, elapsed, context);\n      }\n\n      this.updateTail(elapsed, context);\n    }\n  }\n\n  updateTail(elapsed, context) {\n    // Go backwards from the end, building up paths and letting the dev manually style them\n    // ensuring that there are this.resolution # of paths.\n    if (this.points.length > 1) {\n      var curLen = 0;\n      for (var i = 0; i < this.points.length - 1; i++) {\n        var start = this.points[this.points.length - (i + 1)];\n        var end = this.points[this.points.length - (i + 2)];\n\n        curLen += vec2.len(vec2.sub(vec2.create(), end, start));\n\n        // Let dev manually style points based on ratio of start to end\n        this.pathRedraw(this, start, end, curLen, i / (this.sparkResolution - 1), elapsed, context);\n      }\n    }\n  }\n\n  // Spark()\n  constructor(options) {\n    this.id = options.id || -1; // index of this spark\n    this.pathRedraw = options.pathRedraw; // A function to call to redraw each segment as the spark moves.\n\n    this.sparkResolution = options.sparkResolution || 20; // Resolution (number of segments) of the spark\n\n    this.options = options;\n\n    this.paths = []; // Paper.js Paths of this spark, one for each segment.\n\n    this.sparking = false;\n  }\n}\n\nexport default Spark;\n","import Spark from './gx/Spark.js';\n\nclass Lib {\n  constructor() {\n    this.Spark = Spark;\n  }\n}\n\nexport default new Lib();\n"],"sourceRoot":"/source/"}